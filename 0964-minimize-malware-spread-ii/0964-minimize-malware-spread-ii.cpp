class Solution {
public:
    vector<vector<int>> g;
    int n;
    unordered_set<int> S;
    vector<bool> vis;
    void dfs(int u, int p, int&sz, bool &affect, int x) {
        vis[u] = 1;
        if (S.count(u)) affect = 1;
        sz++;
        for (auto v : g[u]) if (v != p && !vis[v] && v != x)
            dfs(v, u, sz, affect, x);
    }
    int cal(int x) {
        vis.assign(n, false);
        int ans = 0;
        for (int i = 0; i < n; i++) if (i != x && !vis[i]) {
            bool affect = false;
            int sz = 0;
            dfs(i, -1, sz, affect, x);
            if (affect) ans += sz;
        }
        return ans;
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int mn = INT_MAX, idx = INT_MAX;
        n = graph.size();
        g.resize(n);
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++) if (i != j && graph[i][j]) g[i].push_back(j);
        for (auto x : initial) S.insert(x);
        for (auto x : initial) {
            int affected = cal(x);
            if (mn > affected) {
                mn = affected;
                idx = x;
            } else if (mn == affected) {
                idx = min(idx, x);
            }
        }
        return idx;
    }
};